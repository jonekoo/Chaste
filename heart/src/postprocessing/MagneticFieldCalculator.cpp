#include "MagneticFieldCalculator.hpp"
//#include "PetscTools.hpp"  // to get matrix_row
#include "UblasCustomFunctions.hpp"


c_vector<double, 3> CrossProduct(const c_vector<double, 3>& u, const c_vector<double, 3>& v)
{
    c_vector<double, 3> result;
    result[0] = u[1] * v[2] - u[2] * v[1];
    result[1] = u[2] * v[0] - u[0] * v[2];
    result[2] = u[0] * v[1] - u[1] * v[0];
    return result;
}


template<unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM>
double MagneticFieldCalculator<ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM> ::GetIntegrand(ChastePoint<SPACE_DIM>& rX,
                                    c_vector<double,PROBLEM_DIM>& rU,
                                    c_matrix<double,PROBLEM_DIM,SPACE_DIM>& rGradU)
{
    c_vector<double,SPACE_DIM> r_vector = mObservationPoint.rGetLocation()- rX.rGetLocation();
    double norm_r = norm_2(r_vector);
    if (norm_r <= DBL_EPSILON)
    {
        EXCEPTION("Observation point is on a mesh Gauss point");  // Probably needed?
    }
    matrix_row<c_matrix<double, PROBLEM_DIM, SPACE_DIM> > currentDensity(rGradU, 0);
    // Coefficient 0.1 below is needed to convert the potential gradient from
    // Chaste's mV/cm to V/m.
    currentDensity *= -mConductivity;  // TODO: include tensor conductivity
    // Coefficient
    c_vector<double, SPACE_DIM> grad_one_over_r = -r_vector * SmallPow( 1/norm_r, 3);
    double integrand = CrossProduct(currentDensity ,-grad_one_over_r)[0];
    return 1.0e-9 * integrand;  // including the mu0 per 4 pi in H/cm
}


template<unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM>
MagneticFieldCalculator<ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM>::MagneticFieldCalculator(
    AbstractTetrahedralMesh<ELEMENT_DIM,SPACE_DIM>& rMesh,
    const ChastePoint<SPACE_DIM>& rObservationPoint,
    const FileFinder& rDirectory,
    const std::string& rHdf5FileName,
    const std::string& rVariableName,
    unsigned timestepStride)
  : mrMesh(rMesh),
    mObservationPoint(rObservationPoint),
    mVariableName(rVariableName),
    mTimestepStride(timestepStride)
{
    mpDataReader = new Hdf5DataReader(rDirectory, rHdf5FileName);
    mNumberOfNodes = mpDataReader->GetNumberOfRows();
    mNumTimeSteps = mpDataReader->GetVariableOverTime(mVariableName, 0u).size();
    //check that the hdf file was generated by simulations from the same mesh
    assert(mNumberOfNodes == mrMesh.GetNumNodes());
    mConductivity = 10.; // TODO: Set to a tissue-specific value, (mS/cm)
}


template<unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM>
double MagneticFieldCalculator<ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM>::ComputeMagneticFieldAtOneTimeStep (unsigned timeStep)
{
    Vec solution_at_one_time_step = PetscTools::CreateVec(mNumberOfNodes);
    mpDataReader->GetVariableOverNodes(solution_at_one_time_step, mVariableName, timeStep);

    double magnetic_field_at_one_timestep;
    try
    {
        magnetic_field_at_one_timestep = this->Calculate(mrMesh, solution_at_one_time_step);
    }
    catch (Exception &e)
    {
        PetscTools::Destroy(solution_at_one_time_step);
        throw e;
    }
    PetscTools::Destroy(solution_at_one_time_step);
    return magnetic_field_at_one_timestep;
}


template<unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM>
MagneticFieldCalculator<ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM>::~MagneticFieldCalculator()
{
    delete mpDataReader;
}

// Explicit instantiation
template class MagneticFieldCalculator<3,3,1>;
// template class MagneticFieldCalculator<3,3,2>; //add this when implemented 